<!doctype html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1"><meta property="twitter:account_id" content="1510101733"><meta name="description" content="The personal blog of Thomas Steiner"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="monetization" content="$pay.stronghold.co/1a1c51358527bef4dc7bcc3e92b155ec07a"><meta name="theme-color"><link rel="icon" href="/images/thomas_steiner.jpg"><link rel="canonical" href="/blogccasion/2018/08/22/service-worker-caching-strategies-based-on-request-types-114542/"><link rel="alternate" href="/blogccasion/feed/feed.xml" type="application/atom+xml" title="Blogccasion"><link rel="author" href="https://tomayac.com/humans.txt" type="text/plain"><link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin><link href="https://fonts.googleapis.com/css?family=Ubuntu&display=swap" rel="stylesheet"><script>if (window.matchMedia('(prefers-color-scheme: dark)').media === 'not all') {
        document.documentElement.style.display = 'none';
        document.head.insertAdjacentHTML(
            'beforeend',
            '<link rel="stylesheet" href="/light.css" onload="document.documentElement.style.display = \'\'">'
        );
      }</script><link rel="stylesheet" href="/css/light.css" media="(prefers-color-scheme:light),(prefers-color-scheme:no-preference)"><link rel="stylesheet" href="/css/dark.css" media="(prefers-color-scheme:dark)"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/css/prism-theme.css"><link rel="webmention" href="https://webmention.io/blog.tomayac.com/webmention"><link rel="pingback" href="https://webmention.io/blog.tomayac.com/xmlrpc"><title>Service Worker Caching Strategies Based on Request Types</title><script type="module" src="/js/script.mjs"></script></head><body><div class="container"><header><a href="/"><h1>blogccasion</h1></a><div class="header-footer-text"><span lang="fr"><strong>l'occasion</strong> <em>f</em> — </span><span lang="de">Gelegenheit</span> <em>f</em>, die ~ , der ~; <em>bei Gelegenheit</em> — <span lang="fr"><strong>à l'occasion</strong></span></div></header><main class="tmpl-post"><article><header><a href="/blogccasion/2018/08/22/service-worker-caching-strategies-based-on-request-types-114542/"><h3>Service Worker Caching Strategies Based on Request Types</h3></a><div class="metadata post-date"><img class="author" src="/images/thomas_steiner.jpg" alt="Thomas Steiner headshot"><p>By <a href="/about/">Thomas Steiner</a>. Written on <time datetime="2018-08-22T11:45:42.000Z">Wed Aug 22 2018</time>. <a href="/tags/Technical" class="tag"><b>Technical</b></a></p></div></header><p>(This article was cross-posted to <a href="https://medium.com/dev-channel/service-worker-caching-strategies-based-on-request-types-57411dd7652c">Medium.com</a>.)</p><h4 id="ce36">TL;DR</h4><p id="f502">Instead of purely relying on URL-based pattern matching, also consider leveraging the lesser-known--but super useful--<code><a href="https://developer.mozilla.org/en-US/docs/Web/API/Request/destination" data-href="https://developer.mozilla.org/en-US/docs/Web/API/Request/destination" rel="nofollow noopener nofollow noopener" target="_blank">Request.destination</a></code> property in your service worker to determine the type and/or caching strategy of requests. Note, though, that <code>Request.destination</code> gets set to the non-informative empty string default value for <code>XMLHttpRequest</code> or <code>fetch()</code> calls. You can play with the <code><a href="https://request-destination-playground.glitch.me/" data-href="https://request-destination-playground.glitch.me/" rel="nofollow noopener noopener nofollow noopener" target="_blank">Request.destination</a></code><a href="https://request-destination-playground.glitch.me/" data-href="https://request-destination-playground.glitch.me/" rel="nofollow noopener noopener nofollow noopener" target="_blank">playground app</a> to see <code>Request.destination</code> in action.</p><h4 id="e541">Different Caching Strategies for Different Types of Resources</h4><p id="fd06">When it comes to establishing caching strategies for Progressive Web Apps, not all resources should be treated equally. For example, for a shopping PWA, your API calls that return live data on some items' availabilities might be configured to use a <a href="https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#network-only" data-href="https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#network-only" rel="nofollow noopener nofollow noopener" target="_blank">Network Only</a> strategy, your self-hosted company-owned web fonts might be configured to use a <a href="https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-only" data-href="https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-only" rel="nofollow noopener nofollow noopener" target="_blank">Cache Only</a> strategy, and your other HTML, CSS, JavaScript, and image resources might use a <a href="https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#network-falling-back-to-cache" data-href="https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#network-falling-back-to-cache" rel="nofollow noopener nofollow noopener" target="_blank">Network Falling Back to Cache</a> strategy.</p><h4 id="4b80">URL-based Determination of the Request&nbsp;Type</h4><p id="dc45">Commonly, developers have relied on the known URL structure of their PWAs and regular expressions to determine the appropriate caching strategy for a given request. For example, here's an excerpt of a modified code snippet courtesy of <a href="https://twitter.com/jaffathecake" data-href="https://twitter.com/jaffathecake" rel="nofollow noopener" target="_blank">Jake Archibald</a>'s <a href="https://jakearchibald.com/2014/offline-cookbook/" data-href="https://jakearchibald.com/2014/offline-cookbook/" rel="nofollow noopener" target="_blank">offline cookbook</a>:</p><pre id="ec5a">// In serviceworker.js<br>self.addEventListener('fetch', (event) =&gt; {<br>  // Parse the URL<br>  const requestURL = new URL(event.request.url);<br>  // Handle article URLs<br>  if (/^<strong>\/</strong>article<strong>\/</strong>/.test(requestURL.pathname)) {<br>    event.respondWith(/* some response strategy */);<br>    return;<br>  }<br>  if (/<strong>\.</strong>webp$/.test(requestURL.pathname)) {<br>    event.respondWith(/* some other response strategy */);<br>    return;<br>  }<br>  /*  */<br>});</pre><p id="1add">This approach allows developers to deal with their <a href="https://developers.google.com/speed/webp/" data-href="https://developers.google.com/speed/webp/" rel="nofollow noopener" target="_blank">WebP images</a> (<em>i.e.</em>, requests that match the regular expression <code>/\.webp$/</code>) differently than with their HTML articles (<em>i.e.</em>, requests that match <code>/^\/article\//</code>). The downside of this approach is that it makes hard-coded assumptions about the URL structure of a PWA or the used MIME types' file extensions, which creates a tight coupling between app and service worker logic. Should you move away from WebP to a future superior image format, you would need to remember to update your service worker's logic as well.</p><h4 id="3b5d"><code>Request.destination</code>-based Determination of the Request&nbsp;Type</h4><p id="f402">It turns out, the platform has a built-in way for determining the type of a request: it's called <code><a href="https://fetch.spec.whatwg.org/#concept-request-destination" data-href="https://fetch.spec.whatwg.org/#concept-request-destination" rel="nofollow noopener" target="_blank">Request.destination</a></code> as specified in the <a href="https://fetch.spec.whatwg.org/" data-href="https://fetch.spec.whatwg.org/" rel="nofollow noopener" target="_blank">Fetch Standard</a>. Quoting straight from the spec:</p><blockquote id="4d25"><em>A request has an associated destination, which is the empty string, </em><code><em>"audio"</em></code><em>, </em><code><em>"audioworklet"</em></code><em>, </em><code><em>"document"</em></code><em>, </em><code><em>"embed"</em></code><em>, </em><code><em>"font"</em></code><em>, </em><code><em>"image"</em></code><em>, </em><code><em>"manifest"</em></code><em>, </em><code><em>"object"</em></code><em>, </em><code><em>"paintworklet"</em></code><em>, </em><code><em>"report"</em></code><em>, </em><code><em>"script"</em></code><em>, </em><code><em>"serviceworker"</em></code><em>, </em><code><em>"sharedworker"</em></code><em>, </em><code><em>"style"</em></code><em>, </em><code><em>"track"</em></code><em>, </em><code><em>"video"</em></code><em>, </em><code><em>"worker"</em></code><em>, or </em><code><em>"xslt"</em></code><em>. Unless stated otherwise it is the empty string.</em></blockquote><p id="ef87">The empty string default value is the biggest caveat. Essentially, you can't determine the type of resources that are requested via the following methods:</p><blockquote id="7d4a"><code><a href="https://developer.mozilla.org/en-US/docs/Web/API/Navigator/sendBeacon" data-href="https://developer.mozilla.org/en-US/docs/Web/API/Navigator/sendBeacon" rel="nofollow noopener" target="_blank"><em>navigator.sendBeacon()</em></a></code><em>, </em><code><a href="https://developer.mozilla.org/en-US/docs/Web/API/EventSource" data-href="https://developer.mozilla.org/en-US/docs/Web/API/EventSource" rel="nofollow noopener" target="_blank"><em>EventSource</em></a></code><em>, HTML's </em><code><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a#attr-ping" data-href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a#attr-ping" rel="nofollow noopener" target="_blank"><em>&lt;a ping=""&gt;</em></a></code><em> and </em><code><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/area#attr-ping" data-href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/area#attr-ping" rel="nofollow noopener" target="_blank"><em>&lt;area ping=""&gt;</em></a></code><em>, </em><code><a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" data-href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" rel="nofollow noopener" target="_blank"><em>fetch()</em></a></code><em>, </em><code><a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest" data-href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest" rel="nofollow noopener" target="_blank"><em>XMLHttpRequest</em></a></code><em>, </em><code><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API" data-href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API" rel="nofollow noopener" target="_blank"><em>WebSocket</em></a></code><em>, [and the] </em><a href="https://developer.mozilla.org/en-US/docs/Web/API/Cache" data-href="https://developer.mozilla.org/en-US/docs/Web/API/Cache" rel="nofollow noopener" target="_blank"><em>Cache API</em></a></blockquote><p id="8c44">In practice having <code>Request.destination</code> get set to the non-informative empty string default value matters the most for <code>fetch()</code> and <code>XMLHttpRequest</code>, so at least for resources requested through these techniques, it's oftentimes back to URL-based pattern handling inside your service worker.</p><p id="cf8f">On the bright side, you can determine the type of everything else perfectly fine. I have built a little <code><a href="https://request-destination-playground.glitch.me/" data-href="https://request-destination-playground.glitch.me/" rel="nofollow noopener" target="_blank">Request.destination</a></code><a href="https://request-destination-playground.glitch.me/" data-href="https://request-destination-playground.glitch.me/" rel="nofollow noopener" target="_blank">playground app</a> that shows some of these destinations in action. Note that for the sake of the to-be-demonstrated effect it also contains some anti-patterns like <a href="https://developers.google.com/web/fundamentals/primers/service-workers/registration" data-href="https://developers.google.com/web/fundamentals/primers/service-workers/registration" rel="nofollow noopener" target="_blank">registering the service worker</a> as early as possible and actively circumventing the browser's preloading heuristics (never do this in production).</p><figure><img width="788" height="1600" src="/images/req_dest_img2.png"><figcaption><em>An </em><code><em>&lt;img&gt;</em></code> <em>, two </em><code><em>&lt;p&gt;</em></code> <em>s with background images and triggers for </em><code><em>XMLHttpRequest</em></code> <em>or </em><code><em>fetch()</em></code> <em>, an </em><code><em>&lt;iframe&gt;</em></code> <em>, and a </em><code><em>&lt;video&gt;</em></code> <em>with poster image and timed text&nbsp;track</em></figcaption></figure><p id="b98d">When you think about it, there are a huge number of ways a page can request resources to load. A <code>&lt;video&gt;</code> can load an image as its poster frame and a timed text track file via <code>&lt;track&gt;</code>, apart from the video bytes it obviously loads. A stylesheet can cause images to load that are used somewhere on the page as background images, as well as web fonts. An <code>&lt;iframe&gt;</code> loads an HTML document. Oh, and the HTML document itself can load manifests, stylesheets, scripts, images, and a ton of other elements like <code>&lt;object&gt;</code> that was quite popular in the past to load Flash movies.</p><figure><img width="788" height="1600" src="/images/req_dest_img2.png"><figcaption><code><em>Request.destination</em></code> <em>playground app showing different request&nbsp;types</em></figcaption></figure><p id="9bd9">Coming back to the initial example of the shopping PWA, we could come up with a simple service worker router as outlined in the code below. This router is completely agnostic of the URL structure, so there's no tight coupling at all.</p><pre id="3c43">// In serviceworker.js<br>self.addEventListener('fetch', (event) =&gt; {<br>  const destination = event.request.destination;<br>  switch (destination) {<br>    case 'style':<br>    case 'script':<br>    case 'document':<br>    case 'image': {<br>      event.respondWith(<br>          /* "Network Falling Back to Cache" strategy */);<br>      return;<br>    }<br>    case 'font': {<br>      event.respondWith(/* "Cache Only" strategy */);<br>      return;<br>    }<br>    // All `XMLHttpRequest` or `fetch()` calls where<br>    // `Request.destination` is the empty string default value<br>    default: {<br>      event.respondWith(/* "Network Only" strategy */);<br>      return;<br>    }<br>  }<br>});</pre><h4 id="0828">Browser Support for <code>Request.destination</code></h4><p id="bbe6"><code>Request.destination</code> is universally supported by Chrome, Opera, Firefox, Safari, and Edge. For Chrome, support was added in Chrome 65, so for the unlikely case where your target audience uses older browsers than that, you might want to be careful with fully relying on this feature for your router. Other than that, <code>Request.destination</code> is ready for business. You can see the full details on the corresponding <a href="https://www.chromestatus.com/feature/5629697845100544" data-href="https://www.chromestatus.com/feature/5629697845100544" rel="nofollow noopener" target="_blank">Chrome Platform Status page</a>.</p><h4 id="64cf">When <code>Request.destination</code> isn't&nbsp;Enough</h4><p id="14ec">If you have more complex caching needs, you will soon realize that <em>purely</em> relying on <code>Request.destination</code> is <em>not</em> enough. For example, all your stylesheets may indeed use the same response strategy (and thus be good candidates for <code>Request.destination</code>), however, your HTML documents or API requests might still require different caching logic the more advanced your app gets.</p><p id="6b03">Fortunately, you can freely combine <code>Request.destination</code> with URL-based pattern matching, there's absolutely no harm in doing so. A basic example could be to use <code>Request.destination</code> for dealing with all kinds of images to return a default offline fallback placeholder, and to use <code>Request.url</code> with URL-based pattern matching for other resources. You can likewise decide to have different behavior based on the <code>Request.mode</code> of the request, for instance to check if you are dealing with a navigational request (<code>Request.mode === 'navigate'</code>) in single-page apps.</p><h4 id="e395">Conclusion</h4><p id="be21">Coming up with a reasonable caching strategy for a PWA is hard enough. Having ways to tame this complexity is definitely welcome, so whenever feasible??given your PWA's structure??in addition to URL-based pattern handling, also consider leveraging <code>Request.destination</code> for your service worker's routing logic. It may not be able to handle all routes and there are important exceptions and corner cases, but it's definitely a good idea to reduce the coupling of service worker logic and URL structure as much as possible.</p><h4 id="42bd">Acknowledgements</h4><p id="989b">Thanks to <a href="https://twitter.com/mathias" data-href="https://twitter.com/mathias" rel="nofollow noopener" target="_blank">Mathias Bynens</a>, <a href="https://twitter.com/jeffposnick" data-href="https://twitter.com/jeffposnick" rel="nofollow noopener" target="_blank">Jeff Posnick</a>, <a href="https://twitter.com/addyosmani" data-href="https://twitter.com/addyosmani" rel="nofollow noopener" target="_blank">Addy Osmani</a>, <a href="https://twitter.com/rowan_m" data-href="https://twitter.com/rowan_m" rel="nofollow noopener" target="_blank">Rowan Merewood</a>, and <a href="https://twitter.com/ialbmedina">Alberto Medina</a> for reviewing this article, and again Mathias for his help with debugging emoji encoding in Edge!</p></article><section><h3>Webmentions</h3></section><p>You can <a href="https://github.com/tomayac/blogccasion/tree/master/./posts/2018/2018-08-22_service-worker-caching-strategies-based-on-request-types.html" rel="nofollow">edit this page on GitHub</a>.</p></main><nav><h2>Pages</h2><ul><li><a class="nav-item" href="/blogccasion/">Home</a></li><li><a class="nav-item" href="/blogccasion/posts/">Archive</a></li><li><a class="nav-item" href="/blogccasion/about/">About</a></li></ul><h2>Tags</h2><ul><li><a href="/blogccasion/tags/France/" class="tag">France</a></li><li><a href="/blogccasion/tags/Work/" class="tag">Work</a></li><li><a href="/blogccasion/tags/Technical/" class="tag">Technical</a></li><li><a href="/blogccasion/tags/Private/" class="tag">Private</a></li><li><a href="/blogccasion/tags/Political/" class="tag">Political</a></li></ul></nav><svg xmlns="http://www.w3.org/2000/svg"><symbol id="icon-rss" aria-label="RSS" role="img" viewBox="0 0 512 512"><rect width="512" height="512" rx="15%" fill="#f80"/><circle cx="145" cy="367" r="35" fill="#fff"/><path fill="none" stroke="#fff" stroke-width="60" d="M109 241c89 0 162 73 162 162M109 127c152 0 276 124 276 276"/></symbol><symbol id="icon-twitter" aria-label="Twitter" role="img" viewBox="0 0 512 512"><rect width="512" height="512" rx="15%" fill="#1da1f3"/><path fill="#fff" d="M437 152a72 72 0 0 1-40 12 72 72 0 0 0 32-40 72 72 0 0 1-45 17 72 72 0 0 0-122 65 200 200 0 0 1-145-74 72 72 0 0 0 22 94 72 72 0 0 1-32-7 72 72 0 0 0 56 69 72 72 0 0 1-32 1 72 72 0 0 0 67 50 200 200 0 0 1-105 29 200 200 0 0 0 309-179 200 200 0 0 0 35-37"/></symbol><symbol id="icon-pgp" aria-label="Lock" role="img" viewBox="0 0 512 512"><rect width="512" height="512" rx="15%" fill="#29303d"/><g fill="#29303d"><path stroke="#e0e4eb" stroke-width="32" d="M346 214v-37c0-123-180-123-180 0v37"/><rect fill="#ff0" height="210" rx="5%" width="280" x="115" y="210"/><circle cx="256" cy="296" r="28"/><path d="M262 296h-12l-16 69h44"/></g></symbol><symbol id="icon-github" aria-label="GitHub" role="img" viewBox="0 0 512 512"><rect width="512" height="512" rx="15%" fill="#1B1817"/><path fill="#fff" d="M335 499c14 0 12 17 12 17H165s-2-17 12-17c13 0 16-6 16-12l-1-50c-71 16-86-28-86-28-12-30-28-37-28-37-24-16 1-16 1-16 26 2 40 26 40 26 22 39 59 28 74 22 2-17 9-28 16-35-57-6-116-28-116-126 0-28 10-51 26-69-3-6-11-32 3-67 0 0 21-7 70 26 42-12 86-12 128 0 49-33 70-26 70-26 14 35 6 61 3 67 16 18 26 41 26 69 0 98-60 120-117 126 10 8 18 24 18 48l-1 70c0 6 3 12 16 12z"/></symbol></svg><aside><h2>Related</h2><ul><li><a class="aside-item" href="/blogccasion/feed/feed.xml" rel="me"><svg class="icon"><use xlink:href="#icon-rss"></use></svg> Blog Feed</a></li><li><a class="aside-item" href="https://twitter.com/tomayac" rel="me"><svg class="icon"><use xlink:href="#icon-twitter"></use></svg> Twitter</a></li><li><a class="aside-item" href="https://tomayac.com/tweets" rel="me"><svg class="icon"><use xlink:href="#icon-twitter"></use></svg> Tweet Archive</a></li><li><a class="aside-item" href="https://github.com/tomayac" rel="me"><svg class="icon"><use xlink:href="#icon-github"></use></svg> GitHub</a></li><li><a class="aside-item" href="/pgp_public_key.asc"><svg class="icon"><use xlink:href="#icon-pgp"></use></svg> Public Key</a></li></ul></aside><footer id="footer"><ul class="header-footer-text"><li>© 2005–2019 <a class="footer-link" href="/about">Thomas Steiner</a>.</li><li>Distributed under <a class="footer-link" rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a>.</li><li>Contact and required <a class="footer-link" href="/about/">legal info</a>.</li></ul><dark-mode-toggle permanent dark="Light Theme" light="Dark Theme"></dark-mode-toggle><a class="validator" href="https://validator.w3.org/nu/?doc=https://blog.tomayac.com//blogccasion/2018/08/22/service-worker-caching-strategies-based-on-request-types-114542/"><img src="/static/validhtml5.svg" width="88" height="31" alt="Valid HTML5 badge"></a></footer></div></body></html>